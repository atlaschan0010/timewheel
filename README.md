# â±ï¸ Adaptive Hybrid Timer Scheduler (AHTS)

[![Go Reference](https://pkg.go.dev/badge/github.com/atlaschan000/timewheel.svg)](https://pkg.go.dev/github.com/atlaschan000/timewheel)
[![Go Report Card](https://goreportcard.com/badge/github.com/atlaschan000/timewheel)](https://goreportcard.com/report/github.com/atlaschan000/timewheel)

è‡ªé€‚åº”æ··åˆå®šæ—¶è°ƒåº¦å™¨ â€”â€” ä¸€ç§é¢å‘é«˜å¹¶å‘åœ¨çº¿æœåŠ¡çš„é«˜æ€§èƒ½å®šæ—¶ä»»åŠ¡è°ƒåº¦æ–¹æ¡ˆã€‚

> ä¼ ç»Ÿæ—¶é—´è½®çš„æ ¸å¿ƒçŸ›ç›¾æ˜¯"ä¸€ç§æ•°æ®ç»“æ„è¯•å›¾æ»¡è¶³æ‰€æœ‰æ—¶é—´å°ºåº¦çš„éœ€æ±‚"ã€‚AHTS é€šè¿‡åˆ†å±‚å¼‚æ„æ¶æ„ï¼Œè®©æ¯ç§æ•°æ®ç»“æ„åªåšå®ƒæœ€æ“…é•¿çš„äº‹æƒ…ã€‚

## âœ¨ æ ¸å¿ƒç‰¹æ€§

- **O(1) æ’å…¥ä¸å–æ¶ˆ** â€” è¿‘æœŸä»»åŠ¡é€šè¿‡ç¨€ç–æ—¶é—´è½® + åå‘ç´¢å¼•å®ç°å¸¸æ•°æ—¶é—´æ“ä½œ
- **çœŸæ­£çš„ Tickless** â€” æ— ä»»åŠ¡æ—¶é›¶ CPU ç©ºè½¬ï¼Œç²¾ç¡®ç¡çœ åˆ°ä¸‹ä¸€ä¸ªåˆ°æœŸæ—¶é—´ç‚¹
- **æ¼ tick è¡¥å¿** â€” GC åœé¡¿æˆ–ç³»ç»Ÿè°ƒåº¦å»¶è¿Ÿä¸ä¼šå¯¼è‡´ä»»åŠ¡ä¸¢å¤±
- **åˆ†å±‚å¼‚æ„æ¶æ„** â€” è¿‘æœŸä»»åŠ¡ä½¿ç”¨ç¨€ç–æ—¶é—´è½®ï¼Œè¿œæœŸä»»åŠ¡ä½¿ç”¨è·³è¡¨ï¼Œå„å–æœ€ä¼˜
- **æƒ°æ€§è¿ç§»** â€” è¿œæœŸä»»åŠ¡åœ¨æ¥è¿‘åˆ°æœŸæ—¶æ‰è¿ç§»åˆ°è¿‘æœŸè½®ï¼Œé¿å…æ— æ•ˆè®¡ç®—
- **å¹¶å‘å®‰å…¨** â€” é€šè¿‡ race detector éªŒè¯ï¼Œæ‰€æœ‰æ“ä½œçº¿ç¨‹å®‰å…¨
- **å‘¨æœŸä»»åŠ¡æ”¯æŒ** â€” å†…ç½®å‘¨æœŸä»»åŠ¡è‡ªåŠ¨é‡æ–°è°ƒåº¦ï¼Œæ¯æ¬¡æ‰§è¡Œåˆ›å»ºç‹¬ç«‹å®ä¾‹é¿å…å¹¶å‘é—®é¢˜
- **é›¶ä¾èµ–** â€” çº¯æ ‡å‡†åº“å®ç°ï¼Œæ— ç¬¬ä¸‰æ–¹ä¾èµ–

## ğŸ—ï¸ æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               Adaptive Hybrid Timer Scheduler                â”‚
â”‚                                                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚   â”‚   Near-term Region   â”‚    â”‚   Far-term Region    â”‚       â”‚
â”‚   â”‚   [0, threshold)     â”‚    â”‚   [threshold, +âˆ)    â”‚       â”‚
â”‚   â”‚                      â”‚    â”‚                      â”‚       â”‚
â”‚   â”‚  Sparse Timing Wheel â”‚â—„â”€â”€â”€â”‚     Skip List        â”‚       â”‚
â”‚   â”‚  â€¢ HashMap<tick,      â”‚æƒ°æ€§â”‚  â€¢ Sorted by time    â”‚       â”‚
â”‚   â”‚    HashMap<id,task>> â”‚è¿ç§»â”‚  â€¢ O(log n) ops      â”‚       â”‚
â”‚   â”‚  â€¢ Reverse index     â”‚    â”‚  â€¢ taskMap for O(1)  â”‚       â”‚
â”‚   â”‚    taskID â†’ tick     â”‚    â”‚    lookup by ID      â”‚       â”‚
â”‚   â”‚  â€¢ Min-heap for O(1) â”‚    â”‚                      â”‚       â”‚
â”‚   â”‚    next-tick lookup  â”‚    â”‚                      â”‚       â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚              â”‚                                               â”‚
â”‚              â–¼                                               â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                              â”‚
â”‚   â”‚   Tickless Wake Engine    â”‚                              â”‚
â”‚   â”‚   â€¢ Precise sleep         â”‚                              â”‚
â”‚   â”‚   â€¢ Zero idle CPU         â”‚                              â”‚
â”‚   â”‚   â€¢ Interruptible by new  â”‚                              â”‚
â”‚   â”‚     tasks via CAS + chan  â”‚                              â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### è¿ä½œæµç¨‹

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  æ’å…¥ä»»åŠ¡     â”‚
                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                    delay < threshold?
                     â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
                     â”‚ Yes       â”‚ No
                     â–¼           â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ ç¨€ç–æ—¶é—´è½®   â”‚ â”‚  è·³è¡¨     â”‚
              â”‚ O(1) æ’å…¥   â”‚ â”‚ O(logn)  â”‚
              â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                    â”‚             â”‚
                    â”‚    æƒ°æ€§è¿ç§»   â”‚
                    â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚   (æ¥è¿‘åˆ°æœŸæ—¶)
                    â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ Tickless   â”‚
              â”‚ ç²¾ç¡®å”¤é†’    â”‚â”€â”€â†’ æ‰§è¡Œåˆ°æœŸä»»åŠ¡
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“¦ å®‰è£…

```bash
go get github.com/atlaschan000/timewheel
```

**è¦æ±‚ï¼š** Go 1.22+

## ğŸš€ å¿«é€Ÿå¼€å§‹

```go
package main

import (
    "fmt"
    "time"
    "github.com/atlaschan000/timewheel"
)

func main() {
    // åˆ›å»ºè°ƒåº¦å™¨ï¼ˆä½¿ç”¨é»˜è®¤é…ç½®ï¼‰
    scheduler := timewheel.New(timewheel.DefaultConfig())

    // å¯åŠ¨è°ƒåº¦å™¨
    scheduler.Start()
    defer scheduler.Stop()

    // è°ƒåº¦ä¸€ä¸ªå»¶è¿Ÿä»»åŠ¡
    scheduler.Schedule(5*time.Second, func() {
        fmt.Println("Task executed!")
    })

    // è°ƒåº¦å¯å–æ¶ˆçš„ä»»åŠ¡
    taskID := scheduler.Schedule(10*time.Second, func() {
        fmt.Println("This won't print")
    })
    scheduler.Cancel(taskID) // O(1) å–æ¶ˆ

    // è°ƒåº¦å‘¨æœŸä»»åŠ¡
    tickerID := scheduler.SchedulePeriodic(1*time.Second, func() {
        fmt.Println("Periodic task!")
    })

    time.Sleep(5 * time.Second)
    scheduler.Cancel(tickerID) // åœæ­¢å‘¨æœŸä»»åŠ¡

    time.Sleep(1 * time.Second)
}
```

## âš™ï¸ é…ç½®

```go
cfg := timewheel.Config{
    TickInterval:       1 * time.Millisecond,  // è¿‘æœŸè½®ç²¾åº¦
    NearTermThreshold:  60 * time.Second,       // è¿‘æœŸ/è¿œæœŸåˆ†ç•Œçº¿
    MigrationBatchSize: 128,                    // æ¯æ¬¡è¿ç§»çš„æœ€å¤§ä»»åŠ¡æ•°
    LazyDeleteEnabled:  true,                   // å¯ç”¨æƒ°æ€§åˆ é™¤
}
scheduler := timewheel.New(cfg)
```

| å‚æ•° | é»˜è®¤å€¼ | è¯´æ˜ |
|------|--------|------|
| `TickInterval` | 1ms | è¿‘æœŸè½®çš„æœ€å°ç²¾åº¦ã€‚å½±å“ä»»åŠ¡è§¦å‘çš„æ—¶é—´è¯¯å·®ä¸Šç•Œ |
| `NearTermThreshold` | 60s | è¿‘æœŸ/è¿œæœŸåˆ†ç•Œçº¿ã€‚ä½äºæ­¤å€¼çš„ä»»åŠ¡è¿›å…¥ç¨€ç–æ—¶é—´è½®ï¼Œå¦åˆ™è¿›å…¥è·³è¡¨ |
| `MigrationBatchSize` | 128 | æ¯æ¬¡ tick æœ€å¤šä»è¿œæœŸç»“æ„è¿ç§»åˆ°è¿‘æœŸè½®çš„ä»»åŠ¡æ•°ï¼Œé˜²æ­¢è¿ç§»é£æš´ |
| `LazyDeleteEnabled` | true | å¯ç”¨æƒ°æ€§åˆ é™¤ï¼Œå–æ¶ˆæ—¶æ ‡è®°è€Œéç«‹å³ç‰©ç†åˆ é™¤ |

### è°ƒä¼˜å»ºè®®

| åœºæ™¯ | TickInterval | NearTermThreshold | è¯´æ˜ |
|------|-------------|-------------------|------|
| WebSocket å¿ƒè·³ | 100ms | 120s | å¿ƒè·³ç²¾åº¦é€šå¸¸ä¸éœ€è¦ 1ms |
| æ¸¸æˆæŠ€èƒ½ CD | 1ms | 60s | éœ€è¦æ¯«ç§’çº§ç²¾åº¦ |
| RPC è¶…æ—¶ | 1ms | 30s | è¶…æ—¶èŒƒå›´çŸ­ï¼Œé˜ˆå€¼å¯é™ä½ |
| å»¶è¿Ÿé˜Ÿåˆ— | 1s | 3600s | ç²¾åº¦è¦æ±‚ä½ï¼Œé˜ˆå€¼å¯æ”¾å¤§ |

## ğŸ“– API

### è°ƒåº¦ä»»åŠ¡

```go
// å»¶è¿Ÿä»»åŠ¡ï¼ˆè‡ªåŠ¨ç”Ÿæˆ IDï¼‰
taskID := scheduler.Schedule(delay, func() { ... })

// å¸¦æŒ‡å®š ID çš„å»¶è¿Ÿä»»åŠ¡ï¼ˆç›¸åŒ ID ä¼šæ›¿æ¢æ—§ä»»åŠ¡ï¼‰
taskID := scheduler.ScheduleWithID("my-task", delay, func() { ... })

// å‘¨æœŸä»»åŠ¡
tickerID := scheduler.SchedulePeriodic(interval, func() { ... })

// å¸¦æŒ‡å®š ID çš„å‘¨æœŸä»»åŠ¡
tickerID := scheduler.SchedulePeriodicWithID("my-ticker", interval, func() { ... })
```

### å–æ¶ˆä»»åŠ¡

```go
// å–æ¶ˆä»»åŠ¡ï¼ˆè¿‘æœŸä»»åŠ¡ O(1)ï¼Œè¿œæœŸä»»åŠ¡ O(log n)ï¼‰
cancelled := scheduler.Cancel(taskID)
```

### ä»»åŠ¡æ›¿æ¢

```go
// ç›¸åŒ ID è°ƒåº¦ä¼šè‡ªåŠ¨å–æ¶ˆæ—§ä»»åŠ¡
scheduler.ScheduleWithID("heartbeat", 30*time.Second, handler1)
// ... ç¨å ...
scheduler.ScheduleWithID("heartbeat", 30*time.Second, handler2) // handler1 è¢«å–æ¶ˆ
```

### ç»Ÿè®¡ä¿¡æ¯

```go
stats := scheduler.Stats()
fmt.Printf("Executed:   %d\n", stats.TasksExecuted)
fmt.Printf("Cancelled:  %d\n", stats.TasksCancelled)
fmt.Printf("Migrated:   %d\n", stats.TasksMigrated)
fmt.Printf("Near-term:  %d\n", stats.NearTermTasks)
fmt.Printf("Far-term:   %d\n", stats.FarTermTasks)
```

### ç”Ÿå‘½å‘¨æœŸ

```go
scheduler.Start() // å¯åŠ¨è°ƒåº¦å¼•æ“ï¼ˆå¹‚ç­‰ï¼Œå¤šæ¬¡è°ƒç”¨å®‰å…¨ï¼‰
scheduler.Stop()  // åœæ­¢è°ƒåº¦å¼•æ“ï¼Œç­‰å¾…å½“å‰æ‰§è¡Œå®Œæˆ
```

## ğŸ“Š æ€§èƒ½

**æµ‹è¯•ç¯å¢ƒï¼š** Apple M3 Max, Go 1.25, macOS

```
BenchmarkSchedule-16              2,184,120       552.2 ns/op     253 B/op    4 allocs/op
BenchmarkCancel-16                6,472,408       238.6 ns/op       0 B/op    0 allocs/op
BenchmarkScheduleAndCancel-16     2,344,303       520.6 ns/op     388 B/op    7 allocs/op
```

| æ“ä½œ | ååé‡ | å»¶è¿Ÿ | å†…å­˜åˆ†é… |
|------|--------|------|---------|
| è°ƒåº¦ | **~180 ä¸‡/ç§’** | 552 ns | 253 B, 4 allocs |
| å–æ¶ˆ | **~420 ä¸‡/ç§’** | 239 ns | **é›¶åˆ†é…** |
| è°ƒåº¦+å–æ¶ˆ | **~190 ä¸‡/ç§’** | 521 ns | 388 B, 7 allocs |

### å¯¹æ¯”ä¼ ç»Ÿæ–¹æ¡ˆ

| æ“ä½œ | ä¼ ç»Ÿæ—¶é—´è½® | å±‚çº§æ—¶é—´è½® | Min-Heap | **AHTS** |
|------|-----------|-----------|----------|---------|
| æ’å…¥ | O(1) | O(1) | O(log n) | **O(1)** è¿‘æœŸ |
| å–æ¶ˆ | O(n) é“¾è¡¨éå† | O(n) é“¾è¡¨éå† | O(n) æ‰«æ | **O(1)** åå‘ç´¢å¼• |
| åˆ°æœŸè§¦å‘ | O(k) | O(k) | O(log n) | **O(k)** |
| ç©ºé—´ | O(æ—¶é—´è·¨åº¦) | O(å±‚æ•°Ã—è½®å¤§å°) | O(n) | **O(n)** ç¨€ç– |
| é•¿å»¶æ—¶ | âŒ æº¢å‡º/å†…å­˜çˆ† | âœ… éœ€å±‚çº§è¿ç§» | âœ… | âœ… **æƒ°æ€§è¿ç§»** |
| CPU ç©ºè½¬ | æ¯ tick æ£€æŸ¥ | æ¯ tick æ£€æŸ¥ | sleep åˆ°å †é¡¶ | âœ… **Tickless** |
| æ¼ tick å¤„ç† | âŒ ä»»åŠ¡ä¸¢å¤± | âŒ ä»»åŠ¡ä¸¢å¤± | âœ… | âœ… **æ‰¹é‡è¡¥å¿** |

## ğŸ”§ å†…éƒ¨å®ç°ç»†èŠ‚

### ç¨€ç–æ—¶é—´è½® (`SparseWheel`)

```
å­˜å‚¨ç»“æ„:
  buckets:   map[tick]map[taskID]*Task    // æ­£å‘ï¼štick â†’ ä»»åŠ¡é›†åˆ
  taskIndex: map[taskID]tick              // åå‘ï¼šä»»åŠ¡ â†’ æ‰€åœ¨ tick
  tickHeap:  MinHeap<tick>                // æœ€å°å †ï¼šO(1) è·å–æœ€æ—© tick

Insert(tick, task):   O(1) â€” HashMap æ’å…¥ + å † push
Delete(taskID):       O(1) â€” åå‘ç´¢å¼•å®šä½ tick â†’ HashMap åˆ é™¤
PopTicksUpTo(max):    O(k) â€” ä»å †é¡¶è¿ç»­å¼¹å‡ºï¼Œk ä¸ºåˆ°æœŸä»»åŠ¡æ•°
PeekNextTick():       O(1) â€” å †é¡¶å…ƒç´ 
```

### è·³è¡¨ (`SkipList`)

```
å­˜å‚¨ç»“æ„:
  sorted nodes:  æŒ‰ ExpireAt æ’åºçš„è·³è¡¨èŠ‚ç‚¹
  taskMap:       map[taskID]*SkipListNode   // O(1) æŒ‰ ID å®šä½èŠ‚ç‚¹

Insert(task):        O(log n)
DeleteByID(taskID):  O(log n) â€” å…ˆ O(1) å®šä½èŠ‚ç‚¹ï¼Œå† O(log n) æ›´æ–°æŒ‡é’ˆ
PeekMin():           O(1)    â€” å¤´èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ª
PopMin():            O(1) æ‘Šè¿˜
```

### Tickless å¼•æ“ (`TicklessEngine`)

```
ä¸»å¾ªç¯:
  1. nextWake = min(nearTerm.PeekNextTick, farTerm.PeekMin)
  2. if nextWake == 0: é˜»å¡ç­‰å¾…æ–°ä»»åŠ¡ï¼ˆWaitForTaskï¼‰
  3. SleepUntil(nextWake) â€” å¯è¢«æ–°ä»»åŠ¡ CAS + channel æ‰“æ–­
  4. advance() â€” PopTicksUpTo(currentTick) + æƒ°æ€§è¿ç§»

CAS å”¤é†’æœºåˆ¶:
  NotifyIfEarlier(expireAt):
    for {
      current = atomicLoad()
      if expireAt < current:
        if CAS(current, expireAt): Wake(); return
        continue  // CAS å¤±è´¥ï¼Œé‡è¯•ï¼ˆè§£å†³ ABA é—®é¢˜ï¼‰
      return
    }
```

## ğŸ¯ é€‚ç”¨åœºæ™¯

### âœ… æœ€ä½³åŒ¹é…

| åœºæ™¯ | å…¸å‹ä»»åŠ¡ | ä¸ºä»€ä¹ˆåˆé€‚ |
|------|---------|-----------|
| **WebSocket ç½‘å…³** | å¿ƒè·³è¶…æ—¶ã€æ¶ˆæ¯é‡å‘ã€ç©ºé—²æ¸…ç† | å¤§é‡å®šæ—¶å™¨ + é¢‘ç¹å–æ¶ˆï¼ˆæ–­è¿ï¼‰ |
| **æ¸¸æˆæœåŠ¡å™¨** | æŠ€èƒ½ CDã€Buffã€æˆ¿é—´è¶…æ—¶ | æ¯«ç§’ç²¾åº¦ + æ‰¹é‡å–æ¶ˆï¼ˆç©å®¶æ­»äº¡ï¼‰ |
| **å¾®æœåŠ¡ä¸­é—´ä»¶** | RPC è¶…æ—¶ã€ç†”æ–­å™¨ã€é™æµçª—å£ | QPS æ­£æ¯”çš„å®šæ—¶å™¨åˆ›å»º/å–æ¶ˆ |
| **è¿æ¥æ± /ç¼“å­˜** | è¿æ¥å›æ”¶ã€ç¼“å­˜è¿‡æœŸ | æ··åˆå»¶æ—¶ + å‘¨æœŸæ£€æŸ¥ |

### âš ï¸ éæœ€ä½³åœºæ™¯

| åœºæ™¯ | æ¨èæ›¿ä»£ | åŸå›  |
|------|---------|------|
| Cron å®šæ—¶ä»»åŠ¡ (< 1K) | `time.AfterFunc` / Min-Heap | ä»»åŠ¡é‡å¤ªå°‘ï¼ŒO(1) vs O(log n) æ— åŒºåˆ« |
| æ•°åäº¿çº§åˆ†å¸ƒå¼å®šæ—¶ | Redis / Temporal | å•æœºå†…å­˜ä¸å¤Ÿ |
| ç¡¬å®æ—¶ç³»ç»Ÿ | å›ºå®šæ•°ç»„æ—¶é—´è½® + RTOS | éœ€è¦æœ€å O(1)ï¼Œä¸èƒ½æœ‰ GC |

## ğŸ§ª æµ‹è¯•

```bash
# è¿è¡Œæ‰€æœ‰æµ‹è¯•
go test -v ./...

# è¿è¡Œ race detector
go test -race ./...

# è¿è¡Œ benchmark
go test -bench=. -benchmem
```

## ğŸ“„ è®¸å¯è¯

 Apache-2.0 license
